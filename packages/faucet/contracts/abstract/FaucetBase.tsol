pragma ever-solidity >= 0.62.0;
pragma AbiHeader expire;

import '../interfaces/IFaucet.tsol';
import '../interfaces/IFaucetFactory.tsol';
import './FaucetStorage.tsol';
import '../UserData.tsol';

import '@broxus/contracts/contracts/libraries/MsgFlag.tsol';
import '@broxus/contracts/contracts/platform/Platform.tsol';

abstract contract FaucetBase is FaucetStorage {
    function _reserve() internal virtual pure returns (uint128) {
        return math.max(address(this).balance - msg.value, CONTRACT_MIN_BALANCE);
    }

    function getDetails() external virtual view responsible returns (Details) {
        return {
            value: 0, 
            bounce: false, 
            flag: MsgFlag.REMAINING_GAS 
        } Details (
            claimTokenRoot,
            claimTokenWallet,
            claimTokenBalance,
            owner,
            factory,
            user_data_version,
            faucet_version
        );
    }

    function setUp() internal view virtual {
        // Deploy vault's token wallet
        ITokenRoot(claimTokenRoot).deployWallet{
            value: TOKEN_WALLET_DEPLOY_VALUE, 
            callback: FaucetBase.receiveTokenWalletAddress
        }(
            address(this), // owner
            TOKEN_WALLET_DEPLOY_GRAMS_VALUE // deploy grams
        );
    }

    /*
        @notice Store vault's token wallet address
        @dev Only root can call with correct params
        @param wallet Farm pool's token wallet
    */
    function receiveTokenWalletAddress(
        address wallet
    ) external virtual {
        tvm.rawReserve(_reserve(), 0);
        claimTokenWallet = wallet;
    }

    function requestUpdateUserDataCode(address send_gas_to) external virtual onlyOwner view {
        require (msg.value >= REQUEST_UPGRADE_VALUE, LOW_MSG_VALUE);
        tvm.rawReserve(_reserve(), 0);

        IFaucetFactory(factory).processUpdateFaucetUserDataRequest{
            value: 0, 
            flag: MsgFlag.ALL_NOT_RESERVED
        }(send_gas_to);
    }

    function requestUpgradeFaucet(address send_gas_to) external virtual onlyOwner view {
        require (msg.value >= REQUEST_UPGRADE_VALUE, LOW_MSG_VALUE);
        tvm.rawReserve(_reserve(), 0);

        IFaucetFactory(factory).processUpgradeFaucetRequest{
            value: 0, 
            flag: MsgFlag.ALL_NOT_RESERVED
        }(send_gas_to);
    }

    function updateUserDataCode(
        TvmCell new_code, 
        uint32 new_version, 
        address send_gas_to
    ) external virtual override {
        require (msg.sender == factory, NOT_FACTORY);
        tvm.rawReserve(_reserve(), 0);

        if (new_version == user_data_version) {
            send_gas_to.transfer(
                { value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED }
            );
            return;
        }

        userDataCode = new_code;
        emit UserDataCodeUpdated(user_data_version, new_version);
        user_data_version = new_version;

        send_gas_to.transfer(0, false, MsgFlag.ALL_NOT_RESERVED);
    }

    function forceUpgradeUserData(
        address user, 
        address send_gas_to
    ) external virtual override {
        require (msg.sender == factory, NOT_FACTORY);
        tvm.rawReserve(_reserve(), 0);

        address user_data = getUserDataAddress(user);
        IUserData(user_data).upgrade{
            value: 0, 
            flag: MsgFlag.ALL_NOT_RESERVED
        }(userDataCode, user_data_version, send_gas_to);
    }

    function upgradeUserData(address send_gas_to) external virtual view {
        require (msg.value >= USER_DATA_UPGRADE_VALUE, LOW_MSG_VALUE);
        tvm.rawReserve(_reserve(), 0);

        address user_data = getUserDataAddress(msg.sender);
        IUserData(user_data).upgrade{
            value: 0, 
            flag: MsgFlag.ALL_NOT_RESERVED
        }(userDataCode, user_data_version, send_gas_to);
    }

    function dummy(address user_wallet) external pure virtual {
        user_wallet; 
        tvm.rawReserve(_reserve(), 0); 
    }

    function getUserDataAddress(address user) public virtual view responsible returns (address) {
        return { 
            value: 0, 
            flag: MsgFlag.REMAINING_GAS, 
            bounce: false 
        } address(tvm.hash(_buildInitData(_buildUserDataParams(user))));
    }

    function claim(
        address send_gas_to, 
        uint32 nonce
    ) external view virtual {
        tvm.rawReserve(_reserve(), 0);

        address userDataAddr = getUserDataAddress(msg.sender);
        // we cant check if user has any balance here, delegate it to UserData
        IUserData(userDataAddr).processClaim{
            value: 0, 
            flag: MsgFlag.ALL_NOT_RESERVED
        }( 
            send_gas_to, 
            nonce, 
            user_data_version
        );
    }

    function _buildUserDataParams(address user) internal virtual pure returns (TvmCell) {
        TvmBuilder builder;
        builder.store(user);
        return builder.toCell();
    }

    function _buildInitData(TvmCell _initialData) internal virtual view returns (TvmCell) {
        return tvm.buildStateInit({
            contr: Platform,
            varInit: {
                root: address(this),
                platformType: 0, // we have only 1 type
                initialData: _initialData,
                platformCode: platformCode
            },
            pubkey: 0,
            code: platformCode
        });
    }

    modifier onlyOwner() {
        require(msg.sender == owner, NOT_OWNER);
        _;
    }
}