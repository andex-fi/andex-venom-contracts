pragma ever-solidity >= 0.62.0;
pragma AbiHeader expire;

import './interfaces/IUserData.tsol';
import './interfaces/IFaucet.tsol';

import '@broxus/contracts/contracts/libraries/MsgFlag.tsol';

contract UserData is IUserData {
    uint32 current_version;
    TvmCell platform_code;

    address faucet;
    address user;

    uint128 claimAmount;

    mapping (address => uint32) lastClaimTime;

    uint8 constant NOT_FAUCET = 101;
    uint128 constant CONTRACT_MIN_BALANCE = 0.1 ever;
    uint32 constant MAX_VESTING_RATIO = 1000;
    uint256 constant SCALING_FACTOR = 1e18;

    // Cant be deployed directly
    constructor() public { revert(); }


    // should be called in onCodeUpgrade on platform initialization
    function _init(uint128 claim_tokens_amount) internal {
        require (faucet == msg.sender, NOT_FAUCET);
        claimAmount = claim_tokens_amount;
    }

    function _reserve() internal pure returns (uint128) {
        return math.max(address(this).balance - msg.value, CONTRACT_MIN_BALANCE);
    }

    function getLastClaimTime() internal view returns (uint32) {
        return lastClaimTime[user];
    }

    function getDetails() external responsible view override returns (UserDataDetails) {
        return {
            value: 0,
            bounce: false,
            flag: MsgFlag.REMAINING_GAS
        } UserDataDetails (
            faucet,
            user,
            current_version,
            getLastClaimTime()
        );
    }

    function _withdraw(
        address send_gas_to,
        uint32 nonce
    ) internal view {
        IFaucet(msg.sender).finishWithdraw {
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED
        } (user, claimAmount, send_gas_to, nonce);
    }

    function processClaim(
        address send_gas_to,
        uint32 nonce,
        uint32 code_version
    ) external override {
        code_version;
        require (msg.sender == faucet, NOT_FAUCET);
        tvm.rawReserve(_reserve(), 0);

        _withdraw(send_gas_to, nonce);
    }

    function upgrade(
        TvmCell new_code, 
        uint32 new_version, 
        address send_gas_to
    ) external virtual override {
        require (msg.sender == faucet, NOT_FAUCET);

        if (new_version == current_version) {
            tvm.rawReserve(_reserve(), 0);
            send_gas_to.transfer({ value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED });
            return;
        }

        TvmBuilder main_builder;
        main_builder.store(faucet);
        main_builder.store(uint8(0));
        main_builder.store(send_gas_to);

        main_builder.store(platform_code);

        TvmBuilder initial_data;
        initial_data.store(user);

        TvmBuilder params;
        params.store(new_version);
        params.store(current_version);

        main_builder.storeRef(initial_data);
        main_builder.storeRef(params);

        TvmBuilder data_builder;
        data_builder.store(claimAmount); // 128

        main_builder.storeRef(data_builder);

        // set code after complete this method
        tvm.setcode(new_code);

        // run onCodeUpgrade from new code
        tvm.setCurrentCode(new_code);
        onCodeUpgrade(main_builder.toCell());
    }

    function onCodeUpgrade(TvmCell upgrade_data) private {
        tvm.resetStorage();
        tvm.rawReserve(_reserve(), 0);

        TvmSlice s = upgrade_data.toSlice();
        (address root_, , address send_gas_to) = s.decode(address, uint8, address);
        faucet = root_;

        platform_code = s.loadRef();

        TvmSlice initialData = s.loadRefAsSlice();
        user = initialData.decode(address);

        TvmSlice params = s.loadRefAsSlice();
        uint32 prev_version;
        (current_version, prev_version) = params.decode(uint32, uint32);
        if (prev_version != current_version) {
            // upgrade from old version
            uint32 vestingTime_old;
            TvmSlice data = s.loadRefAsSlice();
            vestingTime_old = data.decode(uint32);
            claimAmount = data.decode(uint128);

            emit UserDataUpdated(prev_version, current_version);
        } else {
            // initialization from platform
            (uint128 tokens_amount) = params.decode(uint128);
            _init(tokens_amount);
        }
        send_gas_to.transfer({ value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED });
    }
}